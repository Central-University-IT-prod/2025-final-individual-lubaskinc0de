# Предисловие
Я Любавский Илья и это мое решение задачи.

Я хочу попросить тех, кто это проверяет, внимательно, полностью, прочитать все что я написал здесь.

# Инструкция по запуску

1. Можно попробовать через make (Makefile писался под Linux и дергает docker compose а не docker-compose)

```
make up
```

2. Либо напрямую
(инструкции под Linux, если что просто адаптируйте команды под винду - убрать sudo и написать docker-compose вместо docker compose)

```
sudo docker compose up --build
```

## Запуск E2E тестов
1. Через make

```
make test
```

2. Напрямую

```
sudo docker compose -f docker-compose.test.yml up --build
```

## Запуск unit-тестов
1. Подготовьте **Python** виртуальное окружение.
2. Нужен **Python** версии >= 3.11 (тестировалось на 3.11.11, 3.12.8, 3.13.1)
3. Установите проект и все его зависимости в **виртуальное окружение**
```
pip install -e ".[test]"
pip install -e ".[lint]"
```
4. (Опционально) запустите линтеры
```
mypy
ruff check
ruff format
```
5. Запустите unit-тестирование
```
pytest tests/unit
```

## Очистка данных приложения
- При тестовом запуске (```sudo docker compose -f docker-compose.test.yml up --build```) запускается отдельный compose который не трогает основную БД.
- При основном запуске (```sudo docker compose up --build```) запускается "продакшен версия" у которой уже есть персистентность
- Чтобы очистить БД продакшен версии запустите:
```
sudo docker compose down -v
```

## Важные моменты
1. Перед тестированием приложения дождитесь его healthcheck в docker-compose, тоесть его можно начинать тестировать когда оно успешно начинает отвечать на пинги (вы увидите это в консоли)

2. API находится по адресу ```http://REDACTED:8080``` и соответствует спецификации OpenAPI которая была дана в задаче

3. У API есть собственная автоматически сгенерированная Swagger-документация по пути ```http://REDACTED:8080/docs``` (не пытайтесь делать из интерфейса сваггера запросы, почему то спека багается и не хочет посылать оттуда запросы нормально хотя через постман все отлично проходит)

4. Проводите тестирование в соответствии со спецификацией OpenAPI (например через постман)

5. Интерфейс Grafana находится по адресу ```http://REDACTED:3000```. Логин пароль: ```admin admin```
Добавьте данные через апи и смотрите там статистику в дашборде Stats

6. Всегда запускайте приложение через команду
```
sudo docker compose up --build
```

Команда
```
sudo docker compose -f docker-compose.test.yml up --build
```

Должна использоваться лишь тогда когда вы хотите запустить тесты! Внимательно следите чтобы вы случайно не начали пользоваться тем сервисом который поднимается при тестах! В нем не сохраняются данные, он только для тестов! 


# Демонстрация работы приложения
## Видео
https://rutube.ru/video/e138059eedb2aef229295c037f1f94c2/

## OpenAPI спека
```http://REDACTED:8080/docs```

(напомню, что из-за непонятного мне бага сваггера кинуть запрос напрямую из него нельзя поэтому используйте постман или любую другую утилиту которая умеет делать HTTP-запросы но в сваггере описаны все форматы запросов и ответов)

## Коллекция запросов Postman
Специально для вас дорогие проверяющие я экспортировал коллекцию со всеми запросами к моему сервису из постмана в виде json-файла, вот он: https://disk.yandex.ru/d/deaBJ69YsHUEGQ

Вы можете зайти в постман и проcто нажав кнопку Import в левом углу рядом с названием Workspace вы сможете увидеть все запросы к сервису и опробовать их.

## Добавление картинок к кампаниям
Реализована возможность прикрепить картинку к рекламной кампании.
Для этого вам нужно отправить запрос:

```
PUT http://REDACTED:8080/advertisers/{advertiser_id}/campaigns/{campaign_id}/attach
```

и обязательно нужно отправить formData, в этой form-data должно быть поле file непосредственно с валидной картинкой.
После этого прямая ссылка на изображение будет показана при просмотре рекламной кампании

<img src="https://i.imgur.com/QxHiZh2.png" width="800" />

## Визуализация статистики
Интерфейс Grafana находится по адресу ```http://REDACTED:3000```. Логин пароль: ```admin admin```
Добавьте данные через апи и смотрите там статистику в дашборде Stats

## Модерация текстов рекламных кампаний
Для включения модерации отправьте запрос
```
PUT http://REDACTED:8080/advertisers/toggle/swears
```

с таким телом:
```
{
    "check_enabled": 1
}
```

Теперь при создании кампании и ее обновлении текст будет модерироватся на маты.

## Генерация рекламных текстов
Для генерации рекламных текстов просто отправьте вот такой запрос:
```
GET http://REDACTED:8080/advertisers/{advertiser_id}/campaigns/generate?ad_title=Покупайте кошельки из кожи утканосов!
```

## Все остальные ручки
Соответствуют условиям и предоставленной нам спецификации OpenAPI

# Схема БД
Таблица client (Клиент)
1. client_id (UUID) — уникальный идентификатор клиента. Используется как первичный ключ.

2. login (Text) — логин клиента

3. age (Integer) — возраст клиента

4. location (Text) — местоположение клиента

5. gender (Enum) — пол клиента. Используется перечисление Gender: Male, Female

Таблица advertiser (Рекламодатель)
1. advertiser_id (UUID) — уникальный идентификатор рекламодателя. Первичный ключ.

2. name (Text) — название рекламодателя

Каждый рекламодатель может создавать несколько рекламных кампаний.

Таблица relevance (Релевантность)
Эта таблица хранит оценку релевантности (мл скор).

1. client_id (UUID) — внешний ключ, ссылающийся на таблицу client

2. advertiser_id (UUID) — внешний ключ, ссылающийся на таблицу advertiser

3. score (Integer) — оценка релевантности рекламодателя для клиента

Таблица campaign (Рекламная кампания)

1. campaign_id (UUID) — уникальный идентификатор кампании

2. advertiser_id (UUID) — внешний ключ, ссылающийся на таблицу advertiser

3. impressions_limit (Integer) — лимит показов для кампании

4. clicks_limit (Integer) — лимит кликов для кампании

5. cost_per_impression (Numeric) — стоимость одного показа

6. cost_per_click (Numeric) — стоимость одного клика

7. ad_title (Text) — заголовок рекламного объявлени

8. ad_text (Text) — текст рекламного объявления

9. start_date (Integer) — дата начала кампании

10. end_date (Integer) — дата окончания кампании

11. age_from (Integer) — минимальный возраст целевой аудитории

12. age_to (Integer) — максимальный возраст целевой аудитории

13. location (Text) — местоположение целевой аудитории

14. gender (Enum) — пол целевой аудитории (Male, Female, ALL)

15. image_path (Text) — путь к изображению для рекламы (url)

16. is_deleted (Boolean) — флаг, указывающий, удалена ли кампания

17. created_at (DateTime) — дата и время создания кампании

Таблица click (Клик)
1. click_id (UUID) — уникальный идентификатор клика. Первичный ключ.

2. ad_id (UUID) — внешний ключ, ссылающийся на таблицу campaign

3. client_id (UUID) — внешний ключ, ссылающийся на таблицу client

4. cost_per_click (Numeric) — стоимость клика

5. day (Integer) — день, в который был совершен клик

6. created_at (DateTime) — дата и время клика

Пара client_id и ad_id должна быть уникальной, чтобы избежать дублирования кликов.

Таблица impression (Показ)
1. impression_id (UUID) — уникальный идентификатор показа. Первичный ключ.

2. ad_id (UUID) — внешний ключ, ссылающийся на таблицу campaign

3. client_id (UUID) — внешний ключ, ссылающийся на таблицу client

4. cost_per_impression (Numeric) — стоимость показа

5. day (Integer) — день, в который был совершен показ

6. created_at (DateTime) — дата и время показа

Пара client_id и ad_id должна быть уникальной внутри таблицы

Связи между таблицами:
- Рекламодатель и кампании: Один рекламодатель может создавать множество кампаний

- Клиент и релевантность: Каждый клиент может иметь оценку релевантности для нескольких рекламодателей.

- Кампании и клики/показы: Каждая кампания может иметь множество кликов и показов

- Клиент и клики/показы: Каждый клиент может совершать клики и показы.

<img src="https://i.imgur.com/lpF7e9x.png" width="800" />

# Обоснованность решения
Я выбрал:
1. nginx:
Проверенный временем реверс прокси, используется чтобы ограничивать максимальный размер картинок которые загружают

2. grafana:
Стандарт в мире визуализации

3. redis:
Используется как быстрая БД для кэширования (кэширую метрики сервиса а также вердикты ллм-фильтра)

4. postgresql:
Мощная реляционная СУБД с которой я хорошо знаком и которая идеально покрывает модель данных в этой задаче

5. minio:
Хорошее S3-подобное обьектное хранилище которое можно развернуть локально, используется для хранения картинок.

6. nginx-s3-gateway:
Позволяет проксировать запросы к minio с поддержкой кешей (использовал для раздачи картинок кампаний)

7. YandexGPT-Lite: дешевая и быстрая модель идеально подходит для таких задач как генерация простых рекламных текстов и модерация

# Показ рекламы
На самом деле алгоритм выбора рекламы довольно прост

1. Первым делом мы проверяем настройки таргетинга
2. Потом убираем те рекламы что уже превысили лимит показов на 5%
3. Отсеиваем удаленные
4. Поощряем в ранжировании те компании которые далеки от выполнения лимитов
5. Уменьшаем ранжирование тех кампаний, что превышают лимит кликов
6. Высчитываем суммарную оценку: профит * вес + релевантность * вес + бонус за лимиты * вес + штраф за превышение кликов 
7. Сортируем по суммарной оценке
